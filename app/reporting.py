"""Reporting utilities for generating evaluation results."""

import json
import logging
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any
from dataclasses import dataclass
from jinja2 import Template

logger = logging.getLogger(__name__)


@dataclass
class EvaluationResult:
    """Single evaluation result."""
    puzzle: str
    framework: str
    model: str
    run_number: int
    status: str  # "Pass" or "Fail"
    error_message: str | None = None
    execution_time: float | None = None


@dataclass
class EvaluationSummary:
    """Summary of all evaluation results."""
    results: List[EvaluationResult]
    total_runs: int
    timestamp: datetime



def collect_results(results: List[EvaluationResult]) -> Dict[str, Any]:
    """Organize results for reporting as: puzzle -> (framework, model) -> [statuses]."""
    organized = {}
    for result in results:
        puzzle_key = result.puzzle
        if puzzle_key not in organized:
            organized[puzzle_key] = {}
        key = (result.framework, result.model)
        if key not in organized[puzzle_key]:
            organized[puzzle_key][key] = []
        organized[puzzle_key][key].append(result.status)
    return organized


def generate_markdown_report(summary: EvaluationSummary, output_path: Path) -> None:
    """Generate a Markdown report suitable for GitHub Pages."""
    
    template_str = """# AgentGym Evaluation Results

Generated on: {{ timestamp }}

## Summary

Total evaluations: {{ total_runs }}

## Results by Puzzle

{% set status_emoji = {'Pass': '✅', 'Fail': '❌'} %}
{% for puzzle_name, results in organized_results.items() %}
### {{ puzzle_name | title }}

| Framework | Model | Run 1 | Run 2 | Run 3 | Success Rate |
|-----------|-------|-------|-------|-------|--------------|
{% for (framework, model), runs in results.items() -%}
| {{ framework }} | {{ model }} | {{ status_emoji.get(runs[0], runs[0]) if runs|length > 0 else 'N/A' }} | {{ status_emoji.get(runs[1], runs[1]) if runs|length > 1 else 'N/A' }} | {{ status_emoji.get(runs[2], runs[2]) if runs|length > 2 else 'N/A' }} | {{ ((runs | select('equalto', 'Pass') | list | length) / (runs|length) * 100) | round(1) if runs else 0 }}% |
{% endfor %}

{% endfor %}

## Detailed Results

{% for result in results %}
- **{{ result.puzzle }}** / {{ result.framework }} / {{ result.model }} / Run {{ result.run_number }}: {{ status_emoji.get(result.status, result.status) }}
{% if result.error_message %}  - Error: {{ result.error_message }}{% endif %}
{% if result.execution_time %}  - Time: {{ result.execution_time|round(2) }}s{% endif %}
{% endfor %}

---
*Generated by AgentGym evaluation framework*
"""

    organized_results = collect_results(summary.results)
    # Get frameworks from config (import here to avoid circular import)
    try:
        import config as agentgym_config
        frameworks = agentgym_config.FRAMEWORKS
    except Exception:
        frameworks = []
    template = Template(template_str)
    content = template.render(
        timestamp=summary.timestamp.strftime("%Y-%m-%d %H:%M:%S"),
        total_runs=summary.total_runs,
        organized_results=organized_results,
        frameworks=frameworks,
        results=summary.results
    )
    output_path.write_text(content)
    logger.info(f"📊 Markdown report generated: {output_path}")


def generate_json_report(summary: EvaluationSummary, output_path: Path) -> None:
    """Generate a JSON report for programmatic access."""
    
    # Convert tuple keys to string for JSON serialization
    def tuple_key_to_str_key(organized):
        out = {}
        for puzzle, results in organized.items():
            out[puzzle] = {f"{fw}|{model}": v for (fw, model), v in results.items()}
        return out

    organized_results = tuple_key_to_str_key(collect_results(summary.results))
    data = {
        "timestamp": summary.timestamp.isoformat(),
        "total_runs": summary.total_runs,
        "results": [
            {
                "puzzle": r.puzzle,
                "framework": r.framework,
                "model": r.model,
                "run_number": r.run_number,
                "status": r.status,
                "error_message": r.error_message,
                "execution_time": r.execution_time
            }
            for r in summary.results
        ],
        "organized_results": organized_results
    }
    output_path.write_text(json.dumps(data, indent=2))
    logger.info(f"📊 JSON report generated: {output_path}")


def save_reports(summary: EvaluationSummary, reports_dir: Path) -> None:
    """Save both Markdown and JSON reports."""
    reports_dir.mkdir(exist_ok=True)
    
    # Generate timestamp-based filenames
    timestamp_str = summary.timestamp.strftime("%Y%m%d_%H%M%S")
    
    # Save timestamped versions
    generate_markdown_report(summary, reports_dir / f"results_{timestamp_str}.md")
    generate_json_report(summary, reports_dir / f"results_{timestamp_str}.json")
    
    # Save latest versions (for GitHub Pages)
    generate_markdown_report(summary, reports_dir / "latest.md")
    generate_json_report(summary, reports_dir / "latest.json")
    
    logger.info(f"📊 Reports saved to {reports_dir}")
